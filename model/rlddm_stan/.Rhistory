warmup  = 1000,
thin    = 1,
control = list(adapt_delta   = 0.95,
stepsize      = 1,
max_treedepth = 10),
verbose =TRUE)
parVals_v2 <- rstan::extract(fit_v2, permuted = TRUE)
fit_summary_v2 <- rstan::summary(fit_v2)
tail(fit_summary_v2$summary)
# t1: initialized at 0.5
parValsinvl$ev_hat[4000,1,]
# show the trajectory for the ev of the 1st stimulus:
## Low association strength
## Value changes at: 9, 16,
parVals_v2$ev_hat[4000,,8]
# t1: initialized at 0.5
parVals_v2l$ev_hat[4000,1,]
# t1: initialized at 0.5
parVals_v2$ev_hat[4000,1,]
# t2: update
parVals_v2l$ev_hat[4000,2,]
# t2: update
parVals_v2$ev_hat[4000,2,]
# t3: update
parVals_v2$ev_hat[4000,3,]
get_astim_trials <- function(data){
df_subj <- list()
#data<-data[data$choice!=0,] # remove 'too slow ' responses
new_data <- data[FALSE,]
new_col_trial <- data.frame(trial_astim = integer(0))
new_data <- cbind(new_data,new_col_trial)
for(i in unique(data$subjID)){
df_subj[[i]] <- subset(data, subjID == i)
for(j in unique(df_subj[[i]]$block)){
df_subj_block <- subset(df_subj[[i]],block==j)
# compute cumulative sum for each auditory stimulus in a given block of a subject
for(k in unique(df_subj_block$aStim)){
df_subj_block_astim <- list()
df_subj_block_astim[[k]] <- subset(df_subj_block, aStim==k )
new_col_trial <- 1:nrow(df_subj_block_astim[[k]])
df_subj_block_astim[[k]]<- cbind(df_subj_block_astim[[k]],new_col_trial)
colnames(df_subj_block_astim[[k]])[ncol(df_subj_block_astim[[k]])] <- "trial_astim"
new_data <- rbind(new_data,df_subj_block_astim[[k]])
# reorder data
new_data <- new_data[
with(new_data, order(subjID, block,trial)),
]
}
}
}
return(new_data)
}
### data loading and preprocessing
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
model_path <- paste0(path,"/rlddm_per_stimulus_v2.stan")
data_path <- paste0(path,"/test_input.txt")
setwd(path)
raw_data <- data.table::fread(file = data_path, header = TRUE, sep = "\t", data.table = TRUE,
fill = TRUE, stringsAsFactors = TRUE, logical01 = FALSE)
raw_data <- cbind(rep(substr(data_path,1,12),dim(raw_data)[1]),raw_data)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(raw_data)[1] <- "subjID"
raw_data$rt <- raw_data$rt/1000
names(raw_data)[names(raw_data)=="rt"] <- "RT"
# automatically filter missed responses (since RT = 0)
raw_data <- raw_data[which(raw_data$RT > 0.15),]
raw_data$subjID = rep('01',nrow(raw_data))
# raw data: fb = 0 incorrect, fb = 1 correct, (fb = 2 missed)
# encoding for simulation: lower (incorrect) response=1, upper (correct) response =2
raw_data$response = raw_data$fb+1
# raw_data$nonresponse = abs(raw_data$fb-2) # not used atm
# split vstim columns
raw_data <- raw_data %>% separate(vStims, c("vStim1", "vStim2"),sep="\\_")
# get new column with non-associated stimulus
raw_data$vStimNassoc <- ifelse(raw_data$aStim==raw_data$vStim1,as.integer(raw_data$vStim2),as.integer(raw_data$vStim1))
raw_data <- get_astim_trials(raw_data)
## prepare data for jags
#raw_data$row <- seq.int(nrow(raw_data))
DT_trials <- raw_data[, .N, by = "subjID"]
subjs     <- DT_trials$subjID
n_subj    <- length(subjs)
# get minRT
minRT <- with(raw_data, aggregate(RT, by = list(y = subjID), FUN = min)[["x"]])
ifelse(is.null(dim(minRT)),minRT<-as.array(minRT))
# since we discarded some observations, we have to assign new trial numbers
for (subj in subjs){
sub <- which(raw_data$subjID==subj)
raw_data[sub,]$trial <- seq.int(nrow(raw_data[sub,]))
}
# first is Sx1 matrix identifying all first trials of a subject for each choice
first <- which(raw_data$trial==1)
# if N=1 transform int to 1-d array
ifelse(is.null(dim(first)),first<-as.array(first))
# last is a Sx1 matrix identifying all last trials of a subject for each choice
last <- as.integer(first + DT_trials$N - 1)
ifelse(is.null(dim(last)),last<-as.array(last))
# incorrect is the inverse vector of choice and is needed to update the ev for the non-choices
raw_data$incorrect <- as.integer(ifelse(raw_data$correct==1, 0, 1))
# define the values for the rewards: if upper resp, value = 1
value <- ifelse(raw_data$response==2, 1, 0)
## all RT with negative choices -> -1
#new_RT <- ifelse(raw_data$correct==1, raw_data$RT*-1, raw_data$RT)
## # obs
n_trials <- nrow(raw_data)
##
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "response" = raw_data$response, "trial_astim" = raw_data$trial_astim,
"stim_assoc" = raw_data$aStim, "stim_nassoc" = raw_data$vStimNassoc, "RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "n_stims"=8)  # names list of numbers
stanmodel_per_stimulus <- rstan::stan_model(model_path)
fit_invlog <- rstan::sampling(object  = stanmodel_per_stimulus,
data    = dat,
init    = "random",
chains  = 2,
iter    = 4000,
warmup  = 1000,
thin    = 1,
control = list(adapt_delta   = 0.95,
stepsize      = 1,
max_treedepth = 10),
verbose =TRUE)
get_astim_trials <- function(data){
df_subj <- list()
#data<-data[data$choice!=0,] # remove 'too slow ' responses
new_data <- data[FALSE,]
new_col_trial <- data.frame(trial_astim = integer(0))
new_data <- cbind(new_data,new_col_trial)
for(i in unique(data$subjID)){
df_subj[[i]] <- subset(data, subjID == i)
for(j in unique(df_subj[[i]]$block)){
df_subj_block <- subset(df_subj[[i]],block==j)
# compute cumulative sum for each auditory stimulus in a given block of a subject
for(k in unique(df_subj_block$aStim)){
df_subj_block_astim <- list()
df_subj_block_astim[[k]] <- subset(df_subj_block, aStim==k )
new_col_trial <- 1:nrow(df_subj_block_astim[[k]])
df_subj_block_astim[[k]]<- cbind(df_subj_block_astim[[k]],new_col_trial)
colnames(df_subj_block_astim[[k]])[ncol(df_subj_block_astim[[k]])] <- "trial_astim"
new_data <- rbind(new_data,df_subj_block_astim[[k]])
# reorder data
new_data <- new_data[
with(new_data, order(subjID, block,trial)),
]
}
}
}
return(new_data)
}
### data loading and preprocessing
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
model_path <- paste0(path,"/rlddm_per_stimulus_v2.stan")
data_path <- paste0(path,"/test_input.txt")
setwd(path)
raw_data <- data.table::fread(file = data_path, header = TRUE, sep = "\t", data.table = TRUE,
fill = TRUE, stringsAsFactors = TRUE, logical01 = FALSE)
raw_data <- cbind(rep(substr(data_path,1,12),dim(raw_data)[1]),raw_data)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(raw_data)[1] <- "subjID"
raw_data$rt <- raw_data$rt/1000
names(raw_data)[names(raw_data)=="rt"] <- "RT"
# automatically filter missed responses (since RT = 0)
raw_data <- raw_data[which(raw_data$RT > 0.15),]
raw_data$subjID = rep('01',nrow(raw_data))
# raw data: fb = 0 incorrect, fb = 1 correct, (fb = 2 missed)
# encoding for simulation: lower (incorrect) response=1, upper (correct) response =2
raw_data$response = raw_data$fb+1
# raw_data$nonresponse = abs(raw_data$fb-2) # not used atm
# split vstim columns
raw_data <- raw_data %>% separate(vStims, c("vStim1", "vStim2"),sep="\\_")
# get new column with non-associated stimulus
raw_data$vStimNassoc <- ifelse(raw_data$aStim==raw_data$vStim1,as.integer(raw_data$vStim2),as.integer(raw_data$vStim1))
raw_data <- get_astim_trials(raw_data)
## prepare data for jags
#raw_data$row <- seq.int(nrow(raw_data))
DT_trials <- raw_data[, .N, by = "subjID"]
subjs     <- DT_trials$subjID
n_subj    <- length(subjs)
# get minRT
minRT <- with(raw_data, aggregate(RT, by = list(y = subjID), FUN = min)[["x"]])
ifelse(is.null(dim(minRT)),minRT<-as.array(minRT))
# since we discarded some observations, we have to assign new trial numbers
for (subj in subjs){
sub <- which(raw_data$subjID==subj)
raw_data[sub,]$trial <- seq.int(nrow(raw_data[sub,]))
}
# first is Sx1 matrix identifying all first trials of a subject for each choice
first <- which(raw_data$trial==1)
# if N=1 transform int to 1-d array
ifelse(is.null(dim(first)),first<-as.array(first))
# last is a Sx1 matrix identifying all last trials of a subject for each choice
last <- as.integer(first + DT_trials$N - 1)
ifelse(is.null(dim(last)),last<-as.array(last))
# incorrect is the inverse vector of choice and is needed to update the ev for the non-choices
raw_data$incorrect <- as.integer(ifelse(raw_data$correct==1, 0, 1))
# define the values for the rewards: if upper resp, value = 1
value <- ifelse(raw_data$response==2, 1, 0)
## all RT with negative choices -> -1
#new_RT <- ifelse(raw_data$correct==1, raw_data$RT*-1, raw_data$RT)
## # obs
n_trials <- nrow(raw_data)
##
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "response" = raw_data$response, "trial_astim" = raw_data$trial_astim,
"stim_assoc" = raw_data$aStim, "stim_nassoc" = raw_data$vStimNassoc, "RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "n_stims"=8)  # names list of numbers
stanmodel_v2 <- rstan::stan_model(model_path)
fit_v2 <- rstan::sampling(object  = stanmodel_v2,
data    = dat,
init    = "random",
chains  = 2,
iter    = 4000,
warmup  = 1000,
thin    = 1,
control = list(adapt_delta   = 0.95,
stepsize      = 1,
max_treedepth = 10),
verbose =TRUE)
parVals_v2 <- rstan::extract(fit_v2, permuted = TRUE)
fit_summary_v2 <- rstan::summary(fit_v2)
# show the trajectory for the ev of the 1st stimulus:
## Low association strength
## Value changes at: 9, 16,
parVals_v2$ev_hat[4000,,8]
# t1: initialized at 0.5
parVals_v2$ev_hat[4000,1,]
# t2: update
parVals_v2$ev_hat[4000,2,]
# t3: update
parVals_v2$ev_hat[4000,3,]
View(stanmodel_v2)
library(boot) #needed for inverse logit
logit(0.03)
get_astim_trials <- function(data){
df_subj <- list()
#data<-data[data$choice!=0,] # remove 'too slow ' responses
new_data <- data[FALSE,]
new_col_trial <- data.frame(trial_astim = integer(0))
new_data <- cbind(new_data,new_col_trial)
for(i in unique(data$subjID)){
df_subj[[i]] <- subset(data, subjID == i)
for(j in unique(df_subj[[i]]$block)){
df_subj_block <- subset(df_subj[[i]],block==j)
# compute cumulative sum for each auditory stimulus in a given block of a subject
for(k in unique(df_subj_block$aStim)){
df_subj_block_astim <- list()
df_subj_block_astim[[k]] <- subset(df_subj_block, aStim==k )
new_col_trial <- 1:nrow(df_subj_block_astim[[k]])
df_subj_block_astim[[k]]<- cbind(df_subj_block_astim[[k]],new_col_trial)
colnames(df_subj_block_astim[[k]])[ncol(df_subj_block_astim[[k]])] <- "trial_astim"
new_data <- rbind(new_data,df_subj_block_astim[[k]])
# reorder data
new_data <- new_data[
with(new_data, order(subjID, block,trial)),
]
}
}
}
return(new_data)
}
### data loading and preprocessing
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
model_path <- paste0(path,"/rlddm_per_stimulus_v2.stan")
data_path <- paste0(path,"/test_input.txt")
setwd(path)
raw_data <- data.table::fread(file = data_path, header = TRUE, sep = "\t", data.table = TRUE,
fill = TRUE, stringsAsFactors = TRUE, logical01 = FALSE)
raw_data <- cbind(rep(substr(data_path,1,12),dim(raw_data)[1]),raw_data)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(raw_data)[1] <- "subjID"
raw_data$rt <- raw_data$rt/1000
names(raw_data)[names(raw_data)=="rt"] <- "RT"
# automatically filter missed responses (since RT = 0)
raw_data <- raw_data[which(raw_data$RT > 0.15),]
raw_data$subjID = rep('01',nrow(raw_data))
# raw data: fb = 0 incorrect, fb = 1 correct, (fb = 2 missed)
# encoding for simulation: lower (incorrect) response=1, upper (correct) response =2
raw_data$response = raw_data$fb+1
# raw_data$nonresponse = abs(raw_data$fb-2) # not used atm
# split vstim columns
raw_data <- raw_data %>% separate(vStims, c("vStim1", "vStim2"),sep="\\_")
# get new column with non-associated stimulus
raw_data$vStimNassoc <- ifelse(raw_data$aStim==raw_data$vStim1,as.integer(raw_data$vStim2),as.integer(raw_data$vStim1))
raw_data <- get_astim_trials(raw_data)
## prepare data for jags
#raw_data$row <- seq.int(nrow(raw_data))
DT_trials <- raw_data[, .N, by = "subjID"]
subjs     <- DT_trials$subjID
n_subj    <- length(subjs)
# get minRT
minRT <- with(raw_data, aggregate(RT, by = list(y = subjID), FUN = min)[["x"]])
ifelse(is.null(dim(minRT)),minRT<-as.array(minRT))
# since we discarded some observations, we have to assign new trial numbers
for (subj in subjs){
sub <- which(raw_data$subjID==subj)
raw_data[sub,]$trial <- seq.int(nrow(raw_data[sub,]))
}
# first is Sx1 matrix identifying all first trials of a subject for each choice
first <- which(raw_data$trial==1)
# if N=1 transform int to 1-d array
ifelse(is.null(dim(first)),first<-as.array(first))
# last is a Sx1 matrix identifying all last trials of a subject for each choice
last <- as.integer(first + DT_trials$N - 1)
ifelse(is.null(dim(last)),last<-as.array(last))
# incorrect is the inverse vector of choice and is needed to update the ev for the non-choices
raw_data$incorrect <- as.integer(ifelse(raw_data$correct==1, 0, 1))
# define the values for the rewards: if upper resp, value = 1
value <- ifelse(raw_data$response==2, 1, 0)
## all RT with negative choices -> -1
#new_RT <- ifelse(raw_data$correct==1, raw_data$RT*-1, raw_data$RT)
## # obs
n_trials <- nrow(raw_data)
##
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "response" = raw_data$response, "trial_astim" = raw_data$trial_astim,
"stim_assoc" = raw_data$aStim, "stim_nassoc" = raw_data$vStimNassoc, "RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "n_stims"=8)  # names list of numbers
stanmodel_per_stimulus <- rstan::stan_model(model_path)
get_astim_trials <- function(data){
df_subj <- list()
#data<-data[data$choice!=0,] # remove 'too slow ' responses
new_data <- data[FALSE,]
new_col_trial <- data.frame(trial_astim = integer(0))
new_data <- cbind(new_data,new_col_trial)
for(i in unique(data$subjID)){
df_subj[[i]] <- subset(data, subjID == i)
for(j in unique(df_subj[[i]]$block)){
df_subj_block <- subset(df_subj[[i]],block==j)
# compute cumulative sum for each auditory stimulus in a given block of a subject
for(k in unique(df_subj_block$aStim)){
df_subj_block_astim <- list()
df_subj_block_astim[[k]] <- subset(df_subj_block, aStim==k )
new_col_trial <- 1:nrow(df_subj_block_astim[[k]])
df_subj_block_astim[[k]]<- cbind(df_subj_block_astim[[k]],new_col_trial)
colnames(df_subj_block_astim[[k]])[ncol(df_subj_block_astim[[k]])] <- "trial_astim"
new_data <- rbind(new_data,df_subj_block_astim[[k]])
# reorder data
new_data <- new_data[
with(new_data, order(subjID, block,trial)),
]
}
}
}
return(new_data)
}
### data loading and preprocessing
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
model_path <- paste0(path,"/rlddm_per_stimulus_v2.stan")
data_path <- paste0(path,"/test_input.txt")
setwd(path)
raw_data <- data.table::fread(file = data_path, header = TRUE, sep = "\t", data.table = TRUE,
fill = TRUE, stringsAsFactors = TRUE, logical01 = FALSE)
raw_data <- cbind(rep(substr(data_path,1,12),dim(raw_data)[1]),raw_data)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(raw_data)[1] <- "subjID"
raw_data$rt <- raw_data$rt/1000
names(raw_data)[names(raw_data)=="rt"] <- "RT"
# automatically filter missed responses (since RT = 0)
raw_data <- raw_data[which(raw_data$RT > 0.15),]
raw_data$subjID = rep('01',nrow(raw_data))
# raw data: fb = 0 incorrect, fb = 1 correct, (fb = 2 missed)
# encoding for simulation: lower (incorrect) response=1, upper (correct) response =2
raw_data$response = raw_data$fb+1
# raw_data$nonresponse = abs(raw_data$fb-2) # not used atm
# split vstim columns
raw_data <- raw_data %>% separate(vStims, c("vStim1", "vStim2"),sep="\\_")
# get new column with non-associated stimulus
raw_data$vStimNassoc <- ifelse(raw_data$aStim==raw_data$vStim1,as.integer(raw_data$vStim2),as.integer(raw_data$vStim1))
raw_data <- get_astim_trials(raw_data)
## prepare data for jags
#raw_data$row <- seq.int(nrow(raw_data))
DT_trials <- raw_data[, .N, by = "subjID"]
subjs     <- DT_trials$subjID
n_subj    <- length(subjs)
# get minRT
minRT <- with(raw_data, aggregate(RT, by = list(y = subjID), FUN = min)[["x"]])
ifelse(is.null(dim(minRT)),minRT<-as.array(minRT))
# since we discarded some observations, we have to assign new trial numbers
for (subj in subjs){
sub <- which(raw_data$subjID==subj)
raw_data[sub,]$trial <- seq.int(nrow(raw_data[sub,]))
}
# first is Sx1 matrix identifying all first trials of a subject for each choice
first <- which(raw_data$trial==1)
# if N=1 transform int to 1-d array
ifelse(is.null(dim(first)),first<-as.array(first))
# last is a Sx1 matrix identifying all last trials of a subject for each choice
last <- as.integer(first + DT_trials$N - 1)
ifelse(is.null(dim(last)),last<-as.array(last))
# incorrect is the inverse vector of choice and is needed to update the ev for the non-choices
raw_data$incorrect <- as.integer(ifelse(raw_data$correct==1, 0, 1))
# define the values for the rewards: if upper resp, value = 1
value <- ifelse(raw_data$response==2, 1, 0)
## all RT with negative choices -> -1
#new_RT <- ifelse(raw_data$correct==1, raw_data$RT*-1, raw_data$RT)
## # obs
n_trials <- nrow(raw_data)
##
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "response" = raw_data$response, "trial_astim" = raw_data$trial_astim,
"stim_assoc" = raw_data$aStim, "stim_nassoc" = raw_data$vStimNassoc, "RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "n_stims"=8)  # names list of numbers
### with fixed learning rates ###
stanmodel_v2 <- rstan::stan_model(model_path)
fit_v2 <- rstan::sampling(object  = stanmodel_v2,
data    = dat,
init    = "random",
chains  = 2,
iter    = 4000,
warmup  = 1000,
thin    = 1,
control = list(adapt_delta   = 0.95,
stepsize      = 1,
max_treedepth = 10),
verbose =TRUE)
parVals_v2 <- rstan::extract(fit_v2, permuted = TRUE)
fit_summary_v2 <- rstan::summary(fit_v2)
# t1: initialized at 0.5
parVals_v2$ev_hat[4000,1,]
# t2: update
parVals_v2$ev_hat[4000,2,]
# t3: update
parVals_v2$ev_hat[4000,3,]
parVals_v2$ev_hat[4000,,38]
parVals_v2$ev_hat[4000,38,]
parVals_v2$delta_hat[4000]
parVals_v2$delta_hat
parVals_v2$delta_hat[4000,]
parVals_v2$delta_hat[4000,]*parVals_v2$v_mod
parVals_v2$delta_hat[4000,]*parVals_v2$v_mod[4000,]
parVals_v2$v_mod
parVals_v2$v_mod[4000,]
print(fit_summary_v2$summary)
print(fit_summary_v2$summary[10,])
print(fit_summary_v2$summary[25,])
print(fit_summary_v2$summary[30,])
print(fit_summary_v2$summary[25,])
print(fit_summary_v2$summary[26,])
print(fit_summary_v2$summary[27,])
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:31,]
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:35,]
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:34,]
# start of ev values print(fit_summary_v2$summary[27,])
transpose(fit_summary_v2$summary[27:34,])
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:34,]
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:34,]$mean
# start of ev values print(fit_summary_v2$summary[27,])
fit_summary_v2$summary[27:34,1]
# start of ev values print(fit_summary_v2$summary[27,])
rbind(fit_summary_v2$summary[27:34,1],fit_summary_v2$summary[35:42,1]
# start of ev values print(fit_summary_v2$summary[27,])
rbind(fit_summary_v2$summary[27:34,1],fit_summary_v2$summary[35:42,1])
# start of ev values print(fit_summary_v2$summary[27,])
rbind(fit_summary_v2$summary[27:34,1],fit_summary_v2$summary[35:42,1])
27+8
for(i in 1:38){}
for(i in 1:38){
27 + (i*8)
}
for(i in 1:38){
print(27 + (i*8))}
# start of ev values print(fit_summary_v2$summary[27,])
ev_mean <-  matrix(data= NA, nrow=dat$T, ncol=8)
ev_mean
ev_mean[1,]
ev_mean[1,] <- fit_summary_v2$summary[27:34,1]
ev_mean[1,]
for(i in 1:38){
ev_mean[i,] <- fit_summary_v2$summary[27+i*8:34+i*8]
}
for(i in 1:38){
ev_mean[i,] <- fit_summary_v2$summary[(27+i*8):(34+i*8),1]
}
ev_meamn
ev_mean
for(i in 0:38){
ev_mean[i,] <- fit_summary_v2$summary[(27+i*8):(34+i*8),1]
}
ev_mean
fit_summary_v2$summary[27,]
fit_summary_v2$summary[26,]
for(i in 1:39){
ev_mean[i,] <- fit_summary_v2$summary[(27+i*8):(34+i*8),1]
}
for(i in 0:38){
ev_mean[i+1,] <- fit_summary_v2$summary[(27+i*8):(34+i*8),1]
}
for(i in 0:38){
ev_mean[i,] <- fit_summary_v2$summary[(27+i*8):(34+i*8),1]
}
ev_mean
#########
fit_summary_v2$summary[27:34,1]
#########
0:38
for(i in 0:38){
ev_mean[i,] <- fit_summary_v2$summary[(19+i*8):(26+i*8),1]
}
#########
ev_mean
26+8*38
fit_summary_v2$summary[330,1]
fit_summary_v2$summary[329,1]
fit_summary_v2$summary[329]
fit_summary_v2$summary[329:330]
fit_summary_v2$summary[,329:330]
fit_summary_v2$summary[329:330,]
fit_summary_v2$summary[331:332,]
fit_summary_v2$summary[331:369]
fit_summary_v2$summary[331:369,]
fit_summary_v2$summary[331:368,]
tail(fit_summary_v2$summary)
