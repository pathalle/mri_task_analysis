datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
compute_cumulative_sums <- function(data){
df_subj <- list()
#data<-data[data$choice!=0,] # remove 'too slow ' responses
new_data <- data[FALSE,]
new_cols <- data.frame(cumsum_fb = integer(0), trial_separate = integer(0))
new_data <- cbind(new_cols,new_data)
for(i in unique(data$subjID)){
df_subj[[i]] <- subset(data, subjID == i)
for(j in unique(df_subj[[i]]$block)){
df_subj_block <- subset(df_subj[[i]],block==j)
# compute cumulative sum for each auditory stimulus in a given block of a subject
for(k in unique(df_subj_block$aStim)){
df_subj_block_astim <- list()
df_subj_block_astim[[k]] <- subset(df_subj_block, aStim==k )
new_col <- cumsum(df_subj_block_astim[[k]]$fb)
new_col_trial <- 1:nrow(df_subj_block_astim[[k]])
new_cols <- cbind(new_col,new_col_trial)
df_subj_block_astim[[k]]<- as_tibble(cbind(new_cols,df_subj_block_astim[[k]]))
colnames(df_subj_block_astim[[k]])[c(1,2)] <- c("cumulsum_fb", "trial_separate")
new_data <- as_tibble(rbind(new_data,df_subj_block_astim[[k]]))
# reorder data
new_data <- new_data[
with(new_data, order(subjID, block,trial)),
]
}
}
}
return(as_tibble(new_data))
}
get_summary_stats <- function(data){
### #How many missing responses per block (fb == 2)
miss_per_block <- data %>%
select(subjID,RT, fb,block) %>%
filter(fb==2)  %>%
group_by(subjID,block) %>%
tally()
### #RTs per block
RT_per_block <- data %>%
select(subjID,RT, fb,block) %>%
filter(fb!=2)  %>%
group_by(subjID, fb,block) %>%
summarise(mean_rt = mean(RT))
### #RTs across blocks
RT_across_blocks <- data %>%
select(subjID,RT, fb) %>%
filter(fb!=2)  %>%
group_by(subjID, fb) %>%
summarise(mean_rt = mean(RT))
## hits per sextile
correct_per_quartile <- data %>%
select(subjID, fb,block, quartile) %>%
filter(fb==1) %>%
group_by(subjID,block,quartile) %>%
tally()
return(list(
"miss_per_block"=miss_per_block,"rt_per_block"=RT_per_block,"rt_across_blocks"=RT_across_blocks,"hits_per_sextile"=correct_per_sextile))
}
split_trials <- function(data){
data$trial <- as.integer(data$trial)
data$quartile <- 0
data[which(data$trial <= 10),]$quartile =
data[which(data$trial > 10 & data$trial <= 20),]$quartile = 2
data[which(data$trial > 20 & data$trial <= 30),]$quartile = 3
data[which(data$trial > 30 & data$trial <= 40),]$quartile = 4
data <- data[
with(data, order(subjID, block,trial)),
]
return(data)
}
## prepare data
data <- gather_data(files)
data <- data[which(data$RT > 0.15),]
#data_with_cumulsum <- compute_cumulative_sums(data)
#data_quartiles <- split_trials(data_with_cumulsum)
#summary_stats <- get_summary_stats(data_sextiles)
#data_with_cumsum <- compute_cumulative_sums(data_sextiles)
# add column with information to which sextile a sequence of trials belongs"
#Save as CSV
setwd(diroutput)
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
task <- "fbl"
#set inputs
dirinput <- "O:/course/biokurs19/mri/logs/feedback/"
# make sure output directory exists already
diroutput <- "O:/course/biokurs19/mri/analysis/feedback/R"
setwd(dirinput)
files <- dir(pattern=".txt", recursive=TRUE)
gather_data <- function(files){
# summarize all data in 1 data frame
datalist <- list()
for (i in 1:length(files)){
no_col <- max(count.fields(files[i], sep = "\t"))
D <- read_delim(
files[i],"\t", escape_double = FALSE, locale = locale(), trim_ws = TRUE)
D <- cbind(rep(substr(files[i],1,12),dim(D)[1]),D)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(D)[1] <- "subj_idx"
D[,1] <- as.factor(D[,1])
D$trial = as.integer(D$trial)
D$aStim = as.integer(D$aStim)
#colnames(D)[grep("rt",colnames(D))] <- "RT"
D[grep("rt",colnames(D))] <- D[grep("rt",colnames(D))]/1000 # RTs in seconds
# don't use grep here, because it will find all instances of 'resp' (even colnames with name respOnset)
names(D)[names(D) == "fb"] <- "response"
#D <- as_tibble(cbind(D,paste(D$vFile,D$aFile)))
#colnames(D)[ncol(D)] <- "pair"
datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
data <- gather_data(files)
data <- data[which(data$RT > 0.15),]
#data_with_cumulsum <- compute_cumulative_sums(data)
#data_quartiles <- split_trials(data_with_cumulsum)
#summary_stats <- get_summary_stats(data_sextiles)
#data_with_cumsum <- compute_cumulative_sums(data_sextiles)
# add column with information to which sextile a sequence of trials belongs"
#Save as CSV
setwd(diroutput)
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
#set inputs
dirinput <- "O:/course/biokurs19/mri/logs/feedback/"
setwd(dirinput)
files <- dir(pattern=".txt", recursive=TRUE)
## prepare data
data <- gather_data(files)
data <- data[which(data$RT > 0.15),]
## prepare data
data <- gather_data(files)
data <- data[which(data$rt > 0.15),]
#data_with_cumulsum <- compute_cumulative_sums(data)
#data_quartiles <- split_trials(data_with_cumulsum)
#summary_stats <- get_summary_stats(data_sextiles)
#data_with_cumsum <- compute_cumulative_sums(data_sextiles)
# add column with information to which sextile a sequence of trials belongs"
#Save as CSV
setwd(diroutput)
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
task <- "fbl"
#set inputs
dirinput <- "O:/course/biokurs19/mri/logs/feedback/"
# make sure output directory exists already
diroutput <- "O:/course/biokurs19/mri/analysis/feedback/R"
setwd(dirinput)
files <- dir(pattern=".txt", recursive=TRUE)
gather_data <- function(files){
# summarize all data in 1 data frame
datalist <- list()
for (i in 1:length(files)){
no_col <- max(count.fields(files[i], sep = "\t"))
D <- read_delim(
files[i],"\t", escape_double = FALSE, locale = locale(), trim_ws = TRUE)
D <- cbind(rep(substr(files[i],10,12),dim(D)[1]),D)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(D)[1] <- "subj_idx"
D[,1] <- as.integer(D[,1])
D$trial = as.integer(D$trial)
D$aStim = as.integer(D$aStim)
#colnames(D)[grep("rt",colnames(D))] <- "RT"
D[grep("rt",colnames(D))] <- D[grep("rt",colnames(D))]/1000 # RTs in seconds
# don't use grep here, because it will find all instances of 'resp' (even colnames with name respOnset)
names(D)[names(D) == "fb"] <- "response"
#D <- as_tibble(cbind(D,paste(D$vFile,D$aFile)))
#colnames(D)[ncol(D)] <- "pair"
datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
data <- gather_data(files)
data <- data[which(data$rt > 0.15),]
#data_with_cumulsum <- compute_cumulative_sums(data)
#data_quartiles <- split_trials(data_with_cumulsum)
#summary_stats <- get_summary_stats(data_sextiles)
#data_with_cumsum <- compute_cumulative_sums(data_sextiles)
# add column with information to which sextile a sequence of trials belongs"
#Save as CSV
setwd(diroutput)
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
View(data)
setwd(dirinput)
files <- dir(pattern=".txt", recursive=TRUE)
gather_data <- function(files){
# summarize all data in 1 data frame
datalist <- list()
for (i in 1:length(files)){
no_col <- max(count.fields(files[i], sep = "\t"))
D <- read_delim(
files[i],"\t", escape_double = FALSE, locale = locale(), trim_ws = TRUE)
D <- cbind(rep(substr(files[i],11,12),dim(D)[1]),D)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(D)[1] <- "subj_idx"
D[,1] <- as.integer(D[,1])
D$trial = as.integer(D$trial)
D$aStim = as.integer(D$aStim)
#colnames(D)[grep("rt",colnames(D))] <- "RT"
D[grep("rt",colnames(D))] <- D[grep("rt",colnames(D))]/1000 # RTs in seconds
# don't use grep here, because it will find all instances of 'resp' (even colnames with name respOnset)
names(D)[names(D) == "fb"] <- "response"
#D <- as_tibble(cbind(D,paste(D$vFile,D$aFile)))
#colnames(D)[ncol(D)] <- "pair"
datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
## prepare data
data <- gather_data(files)
data <- data[which(data$rt > 0.15),]
View(data)
data[,1]
substr(files[i],11,12)
substr(files[1],11,12)
substr(files[2],11,12)
substr(files[3],11,12)
substr(files[4],11,12)
setwd(dirinput)
files <- dir(pattern=".txt", recursive=TRUE)
gather_data <- function(files){
# summarize all data in 1 data frame
datalist <- list()
for (i in 1:length(files)){
no_col <- max(count.fields(files[i], sep = "\t"))
D <- read_delim(
files[i],"\t", escape_double = FALSE, locale = locale(), trim_ws = TRUE)
D <- cbind(rep(substr(files[i],12,12),dim(D)[1]),D)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(D)[1] <- "subj_idx"
D[,1] <- as.integer(D[,1])
D$trial = as.integer(D$trial)
D$aStim = as.integer(D$aStim)
#colnames(D)[grep("rt",colnames(D))] <- "RT"
D[grep("rt",colnames(D))] <- D[grep("rt",colnames(D))]/1000 # RTs in seconds
# don't use grep here, because it will find all instances of 'resp' (even colnames with name respOnset)
names(D)[names(D) == "fb"] <- "response"
#D <- as_tibble(cbind(D,paste(D$vFile,D$aFile)))
#colnames(D)[ncol(D)] <- "pair"
datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
## prepare data
data <- gather_data(files)
data <- data[which(data$rt > 0.15),]
View(data)
substr(files[i],12,12)
substr(files[1],12,12)
substr(files[6],12,12)
gather_data <- function(files){
# summarize all data in 1 data frame
datalist <- list()
for (i in 1:length(files)){
no_col <- max(count.fields(files[i], sep = "\t"))
D <- read_delim(
files[i],"\t", escape_double = FALSE, locale = locale(), trim_ws = TRUE)
D <- cbind(rep(substr(files[i],12,12),dim(D)[1]),D)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(D)[1] <- "subj_idx"
D[,1] <- strtoi(D[,1])
D$trial = as.integer(D$trial)
D$aStim = as.integer(D$aStim)
#colnames(D)[grep("rt",colnames(D))] <- "RT"
D[grep("rt",colnames(D))] <- D[grep("rt",colnames(D))]/1000 # RTs in seconds
# don't use grep here, because it will find all instances of 'resp' (even colnames with name respOnset)
names(D)[names(D) == "fb"] <- "response"
#D <- as_tibble(cbind(D,paste(D$vFile,D$aFile)))
#colnames(D)[ncol(D)] <- "pair"
datalist[[i]] <- D
}
transformed <- data.table::rbindlist(datalist) # combine all data frames in on
return(transformed)
}
## prepare data
data <- gather_data(files)
data <- data[which(data$rt > 0.15),]
View(data)
#data_with_cumulsum <- compute_cumulative_sums(data)
#data_quartiles <- split_trials(data_with_cumulsum)
#summary_stats <- get_summary_stats(data_sextiles)
#data_with_cumsum <- compute_cumulative_sums(data_sextiles)
# add column with information to which sextile a sequence of trials belongs"
#Save as CSV
setwd(diroutput)
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
data <- data[which(data$block ==1)]
write_csv(data,path = paste("performance_all_",task,".csv",sep=""),col_names = TRUE,quote=FALSE)
library(RWiener)
library(ggplot2)
#rwiener(n, alpha,tau,beta,delta)
#restrictions: 0 < β < 1, α > 0, τ > 0
dat <- rwiener(20,2.,0.1,0.5,0.6)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat
)
?Rwiener
?Wwiener
?Wiener
?RWiener
??RWiener
#rwiener(n, alpha,tau,beta,delta)
#restrictions: 0 < β < 1, α > 0, τ > 0
dat <- rwiener(20,2.,0.1,0.5,0.2)
dat <- rwiener(20,2.,0.1,0.5,0.2)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(20,2.,0.1,0.5,-0.1)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
τ > 0
dat <- rwiener(20,2.,0.1,0.5,-0.6)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(20,2.,0.1,0.5,-0.6)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(20,2.,0.1,0.5,-0.8)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,2.,0.1,0.5,-0.8)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,2.,0.1,0.5,0.8)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,2.,0.1,0.5,0.4)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,0.4)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,-0.8)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,2)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,3)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,2.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,2.9)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,2.99)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,3)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,4)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,4)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,3.1)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1.,0.1,0.5,3.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,2.,0.1,0.5,3.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,2,0.1,0.5,3.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,5,0.1,0.5,3.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
dat <- rwiener(40,1,0.1,0.5,3.5)
ggplot(dat) + geom_density() + aes(x=q, fill=resp)
wiener_plot(dat)
library(rstan)
library(RWiener)
library(boot) #needed for inverse logit
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
model_path <- paste0(path,"/rlddm.stan")
data_path <- paste0(path,"/test_input.txt")
setwd(path)
raw_data <- data.table::fread(file = data_path, header = TRUE, sep = "\t", data.table = TRUE,
fill = TRUE, stringsAsFactors = TRUE, logical01 = FALSE)
raw_data <- cbind(rep(substr(data_path,1,12),dim(raw_data)[1]),raw_data)
#D<-D[D$resp!=0,] # remove 'too slow ' responses
### Rename and transform some columns
colnames(raw_data)[1] <- "subjID"
raw_data$rt <- raw_data$rt/1000
names(raw_data)[names(raw_data)=="rt"] <- "RT"
raw_data <- raw_data[which(raw_data$RT > 0.15),]
raw_data$subjID = rep('01',nrow(raw_data))
names(raw_data)[names(raw_data)=="fb"] <- "correct"
## prepare data for jags
#raw_data$row <- seq.int(nrow(raw_data))
DT_trials <- raw_data[, .N, by = "subjID"]
subjs     <- DT_trials$subjID
n_subj    <- length(subjs)
# get minRT
minRT <- with(raw_data, aggregate(RT, by = list(y = subjID), FUN = min)[["x"]])
# assign new trial number for excluded decisions
for (subj in subjs){
sub <- which(raw_data$subjID==subj)
raw_data[sub,]$trial <- seq.int(nrow(raw_data[sub,]))
}
# first is Sx1 matrix identifying all first trials of a subject for each choice
first <- which(raw_data$trial==1)
# last is a Sx1 matrix identifying all last trials of a subject for each choice
last <- as.integer(first + DT_trials$N - 1)
# incorrect is the inverse vector of choice and is needed to update the ev for the non-choices
raw_data$incorrect <- as.integer(ifelse(raw_data$correct==1, 0, 1))
# define the values for the rewards
value <- ifelse(raw_data$correct==1, 0, 1)
## all RT with negative choices -> -1
#new_RT <- ifelse(raw_data$correct==1, raw_data$RT*-1, raw_data$RT)
## # obs
n_trials <- nrow(raw_data)
##
stims <- raw_data$aStim
# generate EV with given parameters
ev <- matrix(data = NA, nrow=dat$T, ncol=2)
delta <- matrix(data=NA, nrow=dat$T,ncol=1)
for(s in 1:dat$N){
ev[first[s],1] <- 0
ev[first[s],2] <- 0
for(trial in (first[s]:last[s]-1)){
delta[trial] = (ev[trial,1]-ev[trial,2]) #* v_mod[s]
ev[trial+1,dat$correct[trial]] = ev[trial,dat$correct[trial]] + logit(eta[s,dat$correct[trial]] * (dat$value[trial]-ev[trial,dat$correct[trial]]))
ev[trial+1,dat$incorrect[trial]] = ev[trial,dat$incorrect[trial]] + logit(eta[s,dat$incorrect[trial]] * (dat$value[trial]-ev[trial,dat$incorrect[trial]]))
}
}
v_mod <- rep(3.566, n_subj)
eta[,1] <- rep(0.032, n_subj)
eta[,2] <- rep(0.023, n_subj)
## Priors
eta_pr = matrix(data= NA, nrow=dat$N, ncol=2)
eta = matrix(data= NA, nrow=dat$N, ncol=2)
a_mod_pr = matrix(data= NA, nrow=dat$N, ncol=1)
a_mod = matrix(data= NA, nrow=dat$N, ncol=1)
v_mod_pr = matrix(data= NA, nrow=dat$N, ncol=1)
v_mod = matrix(data= NA, nrow=dat$N, ncol=1)
tau_pr = matrix(data= NA, nrow=dat$N, ncol=1)
tau = matrix(data= NA, nrow=dat$N, ncol=1)
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "correct" = raw_data$correct, "incorrect" = raw_data$incorrect,
"RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "stims" = stims)  # names list of numbers
## Hyperparameters (group)
mu_pr <- rnorm(6,0,1)
aa <- rnorm(n = 6, mean = 0, s = 0.2)
while(any(aa<0)) { aa <- rnorm(n = 6, mean = 0, s = 0.2) }
sigma <- aa
## Priors
eta_pr = matrix(data= NA, nrow=dat$N, ncol=2)
eta = matrix(data= NA, nrow=dat$N, ncol=2)
a_mod_pr = matrix(data= NA, nrow=dat$N, ncol=1)
a_mod = matrix(data= NA, nrow=dat$N, ncol=1)
v_mod_pr = matrix(data= NA, nrow=dat$N, ncol=1)
v_mod = matrix(data= NA, nrow=dat$N, ncol=1)
tau_pr = matrix(data= NA, nrow=dat$N, ncol=1)
tau = matrix(data= NA, nrow=dat$N, ncol=1)
v_mod <- rep(3.566, n_subj)
eta[,1] <- rep(0.032, n_subj)
eta[,2] <- rep(0.023, n_subj)
ev <- matrix(data = NA, nrow=dat$T, ncol=2)
delta <- matrix(data=NA, nrow=dat$T,ncol=1)
for(s in 1:dat$N){
ev[first[s],1] <- 0
ev[first[s],2] <- 0
for(trial in (first[s]:last[s]-1)){
delta[trial] = (ev[trial,1]-ev[trial,2]) #* v_mod[s]
ev[trial+1,dat$correct[trial]] = ev[trial,dat$correct[trial]] + logit(eta[s,dat$correct[trial]] * (dat$value[trial]-ev[trial,dat$correct[trial]]))
ev[trial+1,dat$incorrect[trial]] = ev[trial,dat$incorrect[trial]] + logit(eta[s,dat$incorrect[trial]] * (dat$value[trial]-ev[trial,dat$incorrect[trial]]))
}
}
ggplot(data = ev, aes(x = ev$1) + geom_line()
plot(1:38, ev[1,])
View(ev)
# generate EV with given parameters
ev <- matrix(data = NA, nrow=dat$T, ncol=2)
delta <- matrix(data=NA, nrow=dat$T,ncol=1)
for(s in 1:dat$N){
ev[first[s],1] <- 0
ev[first[s],2] <- 0
for(trial in (first[s]:last[s]-1)){
delta[trial] = (ev[trial,1]-ev[trial,2]) #* v_mod[s]
ev[trial+1,dat$correct[trial]] = ev[trial,dat$correct[trial]] + inv.logit(eta[s,dat$correct[trial]] * (dat$value[trial]-ev[trial,dat$correct[trial]]))
ev[trial+1,dat$incorrect[trial]] = ev[trial,dat$incorrect[trial]] + inv.logit(eta[s,dat$incorrect[trial]] * (dat$value[trial]-ev[trial,dat$incorrect[trial]]))
}
}
View(ev)
cbin(ev[1,],dat$correct)
cbind(ev[1,],dat$correct)
cbind(ev,dat$correct)
dat$correct
dat$value
# define the values for the rewards
value <- ifelse(raw_data$correct==1, 1, 0)
dat$value
dat <- list("N" = n_subj, "T"=n_trials,"RTbound" = 0.15,"minRT" = minRT, "iter" = raw_data$trial, "correct" = raw_data$correct, "incorrect" = raw_data$incorrect,
"RT" = raw_data$RT, "first" = first, "last" = last, "value"=value, "stims" = stims)  # names list of numbers
dat$value
